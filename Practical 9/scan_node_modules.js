import { promises as fs } from 'fs';
import path from 'path';

// --- Configuration ---

// List of common license file names. Case-insensitive.
const LICENSE_FILES = [
  'LICENSE',
  'LICENSE.MD',
  'LICENSE.TXT',
  'LICENSE.RST',
  'UNLICENSE',
  'UNLICENSE.MD',
  'COPYING',
  'COPYING.MD',
];

// --- Main Scanner Logic ---

/**
 * Finds a license file in a given package directory.
 * @param {string} packagePath - The absolute path to the package directory.
 * @returns {Promise<boolean>} - True if a license file is found, false otherwise.
 */
async function findLicenseFile(packagePath) {
  try {
    const entries = await fs.readdir(packagePath, { withFileTypes: true });
    for (const entry of entries) {
      if (entry.isFile()) {
        const entryNameUpper = entry.name.toUpperCase();
        if (LICENSE_FILES.includes(entryNameUpper)) {
          return true;
        }
      }
    }
  } catch (err) {
    console.error(`[Error] Could not read directory: ${packagePath}`, err.message);
  }
  return false;
}

/**
 * Processes a directory that is confirmed to be a package.
 * Reads its package.json and checks for a license.
 * @param {string} packagePath - The absolute path to the package directory.
 * @param {Map<string, object>} packagesFound - The map to store results.
 */
async function processPackage(packagePath, packagesFound) {
  const packageJsonPath = path.join(packagePath, 'package.json');
  let packageJson;
  
  try {
    const data = await fs.readFile(packageJsonPath, 'utf8');
    packageJson = JSON.parse(data);
  } catch (err) {
    console.warn(`[Warning] Could not read package.json at: ${packagePath}`);
    return;
  }

  const { name, version } = packageJson;
  if (!name || !version) {
    console.warn(`[Warning] Found package.json without name or version at: ${packagePath}`);
    return;
  }

  const key = `${name}@${version}`;
  
  // Avoid re-processing the same package version if found multiple times
  if (packagesFound.has(key)) {
    return;
  }

  const licenseFileFound = await findLicenseFile(packagePath);
  
  packagesFound.set(key, {
    name,
    version,
    path: packagePath,
    licenseFileFound,
  });
}

/**
 * Recursively scans a directory for packages.
 * @param {string} directoryPath - The absolute path to the directory to scan.
 * @param {Map<string, object>} packagesFound - The map to store results.
 * @param {Set<string>} visitedPaths - A set to avoid circular dependencies/symlink loops.
 */
async function scanDirectory(directoryPath, packagesFound, visitedPaths) {
  try {
    // Resolve real path to handle symlinks and avoid loops
    const realPath = await fs.realpath(directoryPath);
    if (visitedPaths.has(realPath)) {
      return;
    }
    visitedPaths.add(realPath);

    const packageJsonPath = path.join(realPath, 'package.json');
    let hasPackageJson = false;

    try {
      // Check if this directory is a package itself
      await fs.stat(packageJsonPath);
      hasPackageJson = true;
    } catch (e) {
      // Not a package directory, treat as a container
    }

    if (hasPackageJson) {
      // This directory is a package, process it
      await processPackage(realPath, packagesFound);
      
      // Also check for nested node_modules
      const nestedNodeModules = path.join(realPath, 'node_modules');
      try {
        await fs.stat(nestedNodeModules);
        await scanDirectory(nestedNodeModules, packagesFound, visitedPaths);
      } catch (e) {
        // No nested node_modules, which is common
      }
    } else {
      // This is a container (like node_modules or a @scope)
      // Read all entries and scan them
      const entries = await fs.readdir(realPath, { withFileTypes: true });
      
      for (const entry of entries) {
        const entryPath = path.join(realPath, entry.name);
        if (entry.isDirectory()) {
          // Recursively scan subdirectories
          await scanDirectory(entryPath, packagesFound, visitedPaths);
        } else if (entry.isSymbolicLink()) {
          // Also follow symlinks (realpath at start of function will handle it)
          await scanDirectory(entryPath, packagesFound, visitedPaths);
        }
      }
    }
  } catch (err) {
    if (err.code !== 'ENOENT' && err.code !== 'EACCES') {
      console.error(`[Error] Failed to scan directory ${directoryPath}:`, err.message);
    }
  }
}

/**
 * Main function to run the scanner.
 */
async function main() {
  const rootNodeModules = path.join(process.cwd(), 'node_modules');
  const packagesFound = new Map();
  const visitedPaths = new Set();

  console.log(`Starting scan of: ${rootNodeModules}\n...`);

  await scanDirectory(rootNodeModules, packagesFound, visitedPaths);

  console.log(`\n--- Scan Complete ---`);
  console.log(`Total unique packages found: ${packagesFound.size}`);

  const packagesWithoutLicense = [];
  for (const [key, pkg] of packagesFound.entries()) {
    if (!pkg.licenseFileFound) {
      packagesWithoutLicense.push(pkg);
    }
  }

  if (packagesWithoutLicense.length === 0) {
    console.log("\n[Success] All packages have a license file!");
  } else {
    console.log(`\n[Report] Found ${packagesWithoutLicense.length} packages without a license file:`);
    packagesWithoutLicense.sort((a, b) => a.name.localeCompare(b.name));
    
    for (const pkg of packagesWithoutLicense) {
      console.log(`  - ${pkg.name}@${pkg.version}`);
      // Log the path for easy checking
      // console.log(`    Path: ${pkg.path}`);
    }
  }
}

// --- Run the script ---
main().catch(err => {
  console.error("\n[Fatal Error] An unexpected error occurred:", err);
  process.exit(1);
});
